module Inspec::Resources
  # This class is responsible for filtering and managing sudoers rules.
  class SudoersRulesFilter
    filter = FilterTable.create
    filter.register_custom_matcher(:exists?) { |x| !x.entries.empty? }
    filter.register_column(:users, field: :users)
    filter.register_column(:hosts, field: :hosts)
    filter.register_column(:run_as, field: :run_as)
    filter.register_column(:tags, field: :tags)
    filter.register_column(:commands, field: :commands)
    filter.register_custom_matcher(:nopasswd?) { |x| x.tags && x.tags.include?('NOPASSWD:') }
    filter.install_filter_methods_on_resource(self, :table)

    attr_reader :table

    def initialize(table)
      @table = table
    end

    def to_s
      'Sudoers Rules'
    end
  end

  # This class is responsible for filtering and managing sudoers settings.
  class SudoersSettingsFilter
    filter = FilterTable.create
    filter.register_custom_matcher(:exists?) { |x| !x.entries.empty? }
    filter.register_custom_matcher(:empty?) { |x| x.entries.empty? }
    filter.register_column(:name, field: :name)                     # user name for user_default type, setting name for others
    filter.register_column(:value, field: :value)                   # the actual value
    filter.register_column(:type, field: :type)                     # user_default, global_default, or alias
    filter.register_column(:setting, field: :setting)               # specific setting name for user defaults
    filter.register_column(:user, field: :user)                     # user name when type is user_default
    filter.register_column(:category, field: :category)             # category for alias type
    filter.register_column(:target_type, field: :target_type)       # user, command, host, or negated_command
    filter.register_column(:target, field: :target)                 # the specific target of the default
    filter.register_column(:binding_type, field: :binding_type)     # user, command, host, or negated_command
    filter.register_column(:binding_target, field: :binding_target) # the specific target of the binding
    filter.register_custom_matcher(:include?) do |x, expected|
      x.entries.any? { |e| e[:value].to_s.include?(expected.to_s) }
    end
    filter.register_column(:values) { |t, _| t.entries.map { |e| e[:value] } }

    # Add new columns to align with settings_hash
    filter.register_column(:binding_details) do |t, _|
      t.entries.map do |e|
        { binding_type: e[:binding_type], binding_target: e[:binding_target], setting: e[:setting], value: e[:value] }
      end
    end

    # Register additional custom matchers if needed
    filter.register_custom_matcher(:has_binding_type?) do |x, expected|
      x.entries.any? { |e| e[:binding_type] == expected }
    end

    filter.install_filter_methods_on_resource(self, :settings)

    attr_reader :settings

    def initialize(settings)
      @settings = transform_settings(settings)
    end

    private

    def transform_settings(settings)
      result = []
      settings.each do |category, values|
        if category == 'Defaults'
          values.each do |key, val|
            if key.include?(':') || key.include?('>') || key.include?('@') || key.include?('!')
              # Handle targeted defaults with multiple settings
              binding_type_symbol = key[0]
              binding_key = key[1..-1].strip

              # Split multiple settings separated by commas
              settings_list = binding_key.split(/\s*,\s*/)

              settings_list.each do |setting_item|
                binding_type, target, setting = extract_binding_details(binding_type_symbol, setting_item)

                # Skip if binding_type or target is nil to prevent adding incomplete entries
                next if binding_type.nil? || target.nil?

                result << {
                  name: target,
                  type: binding_type,
                  target_type: binding_type,
                  target:,
                  setting:,
                  value: val.is_a?(Array) ? val.join(',') : val.to_s,
                  binding_type:,
                  binding_target: target
                }
              end
            else
              # Handle global defaults
              key, value = key.split('=', 2).map(&:strip) if key.include?('=')
              result << {
                name: key,
                value: value ? value.split(/,\s*/) : [],
                type: 'global_default'
              }
            end
          end
        else
          # Handle non-Defaults entries (aliases, etc.)
          category, spec = category.split('_', 2) if category.include?('_')
          sudo_config_hash = {
            name: spec,
            value: values.is_a?(Array) ? values.join(',') : values.to_s,
            type: 'alias',
            category:
          }
          result << sudo_config_hash
        end
      end
      result
    end

    # New helper method to extract binding details
    def extract_binding_details(binding_type_symbol, key)
      binding_type = nil
      target = nil
      setting = nil

      case binding_type_symbol
      when ':'
        binding_type = 'user'
        target, setting = key.split('=', 2).map(&:strip) if key.include?('=')
        target ||= key
      when '>'
        binding_type = 'command'
        target, setting = key.split('=', 2).map(&:strip) if key.include?('=')
        target ||= key
      when '@'
        binding_type = 'host'
        target, setting = key.split('=', 2).map(&:strip) if key.include?('=')
        target ||= key
      when '!'
        binding_type = 'negated_command'
        target, setting = key.split('=', 2).map(&:strip) if key.include?('=')
        target ||= key
      end

      [binding_type, target, setting]
    end

    # Removed parse_targeted_default method
    # def parse_targeted_default(key)
    #   # ...existing code...
    # end
  end

  # This class represents the sudoers resource in InSpec, used to test sudo configuration.
  class Sudoers < Inspec.resource(1)
    name 'sudoers'
    supports platform: 'unix'
    supports platform: 'darwin'
    supports platform: 'freebsd'
    supports platform: 'solaris'
    supports platform: 'aix'
    desc 'Use the sudoers InSpec audit resource to test the configuration of sudo.'
    example <<~EXAMPLE
      # Test that there are no NOPASSWD rules
      describe sudoers.rules.where { !tags.nil? && tags.include?('NOPASSWD:') } do
        it { should_not exist }
      end

      # Test timeout setting
      describe sudoers.settings.where(name: 'timestamp_timeout') do
        its('values') { should cmp 0 }
      end

      # Test that there are no NOPASSWD rules
      describe sudoers.nopasswd_rules do
        it { should_not exist }
      end

      # Get all commands that can be executed without a password
      describe sudoers.nopasswd_commands do
        it { should not include '/usr/bin/su' }
      end

      # Check what commands a specific user can run
      describe sudoers.user_command_map['admin'] do
        it { should not include '/usr/bin/sudo' }
      end

      # Get a summary of all sudo privilege tags in use
      describe sudoers.tag_summary do
        its(['NOPASSWD:']) { should eq 0 }
      end

      # Test user-specific defaults
      describe sudoers.user_defaults('root') do
        its('settings') { should include 'umask' }
        its('values') { should include '027' }
      end

      # Test global defaults
      describe sudoers.global_defaults do
        its('names') { should include 'env_reset' }
      end

      # Test by setting type
      describe sudoers.settings_by_type('user_default') do
        it { should exist }
      end

      # Complex queries using multiple fields
      describe sudoers.settings_filter.where(type: 'user_default', user: 'root', setting: 'umask') do
        its('values') { should cmp '027' }
      end
    EXAMPLE

    attr_reader :lines, :settings, :settings_filter, :sudoers_files, :raw_content, :table

    # List of directives to be ignored during parsing
    # Add any new directives that should be ignored to this list
    # consider adding a test to ensure the directive is ignored
    # consider adding a warning if the directive is not ignored
    # TODO: add a way for the user to pass a directive to ignore to the resource & add tests
    IGNORED_DIRECTIVES = ['#includedir'].freeze

    def initialize(sudoers_files = nil, ignored_directives = IGNORED_DIRECTIVES)
      super()
      @sudoers_files = [sudoers_files || default_sudoers_path].flatten
      @ignored_directives = ignored_directives
      Inspec::Log.debug("sudoers_files: #{@sudoers_files}")

      if @sudoers_files.empty?
        Inspec::Log.warn('No sudoers files found. Skipping resource.')
        skip_resource 'No sudoers files found.'
      end

      load_content
      parse_content
    end

    def rules
      @table
    end

    def resource_id
      @sudoers_files.first || default_sudoers_path
    end

    def to_s
      "Sudoers Configuration #{@sudoers_files.join(', ')}"
    end

    # Add method to expose binding_details
    def binding_details
      settings_filter.binding_details
    end

    # Helper methods that return FilterTable objects
    def rules_with_tag(tag)
      rules.where { !tags.nil? && tags.include?(tag) }
    end

    def nopasswd_rules
      rules_with_tag('NOPASSWD:')
    end

    def noexec_rules
      rules_with_tag('NOEXEC:')
    end

    def loginput_rules
      rules_with_tag('LOG_INPUT:')
    end

    def logoutput_rules
      rules_with_tag('LOG_OUTPUT:')
    end

    # Convenience methods that return arrays of specific attributes
    def nopasswd_commands
      nopasswd_rules.entries.map { |r| r[:commands] }.flatten
    end

    def noexec_commands
      noexec_rules.entries.map { |r| r[:commands] }.flatten
    end

    def logged_commands
      commands = []
      (loginput_rules.entries + logoutput_rules.entries).each do |rule|
        commands += if rule[:commands].is_a?(Array)
                      rule[:commands].map { |cmd| parse_commands(cmd) }
                    else
                      parse_commands(rule[:commands])
                    end
      end
      commands.flatten.uniq
    end

    # Methods that return hashes for easy querying
    def user_command_map
      rules.entries.each_with_object({}) do |rule, hash|
        hash[rule[:users]] ||= []
        hash[rule[:users]] += Array(rule[:commands])
      end
    end

    def tag_summary
      rules.entries.each_with_object(Hash.new(0)) do |rule, hash|
        next unless rule[:tags]

        rule[:tags].split(/\s+/).each { |tag| hash[tag] += 1 }
      end
    end

    # Helper methods
    def authenticate?
      !@settings_filter.where { name == 'Defaults:!authenticate' }.entries.empty?
    end

    def timeout_value
      timeout = @settings_filter.where { name == 'Defaults:timestamp_timeout' }.values.flatten.first
      timeout ? timeout.to_i : nil
    end

    def timeout_value?
      !timeout_value.nil?
    end

    def user_aliases
      @settings_filter.where { name.start_with?('User_Alias') }
    end

    def command_aliases
      @settings_filter.where { name.start_with?('Cmnd_Alias') }
    end

    def defaults
      @settings_filter.where { name.start_with?('Defaults') }
    end

    def user_defaults(user)
      settings_filter.where(type: 'user_default', user:)
    end

    def global_defaults
      settings_filter.where(type: 'global_default')
    end

    def all_aliases
      settings_filter.where(type: 'alias')
    end

    def settings_by_type(type)
      settings_filter.where(type:)
    end

    # Add new helper methods for binding types
    def binding_defaults(type: nil, target: nil)
      where_clause = { type: 'binding' }
      where_clause[:binding_type] = type if type
      where_clause[:binding_target] = target if target
      settings_filter.where(where_clause)
    end

    def user_binding_defaults(user)
      binding_defaults(type: 'user', target: user)
    end

    def command_binding_defaults(command)
      binding_defaults(type: 'command', target: command)
    end

    def host_binding_defaults(host)
      binding_defaults(type: 'host', target: host)
    end

    def negated_command_defaults(command)
      binding_defaults(type: 'negated_command', target: command)
    end

    private

    def default_sudoers_path
      path = case inspec.os.name
             when 'darwin'
               '/private/etc/sudoers'
             when 'freebsd'
               '/usr/local/etc/sudoers'
             when 'solaris'
               '/etc/opt/sudoers'
             when 'aix'
               '/etc/security/sudoers'
             else
               '/etc/sudoers'
             end

      Inspec::Log.warn("Default sudoers path #{path} does not exist.") unless inspec.file(path).exist?

      path
    end

    def load_content
      @raw_content = inspec.command("cat #{@sudoers_files.join(' ')}").stdout
      if @raw_content.empty?
        Inspec::Log.warn("Failed to load content from sudoers files: #{@sudoers_files.join(', ')}")
        skip_resource 'Failed to load content from sudoers files.'
      end
      Inspec::Log.debug("raw_content: #{@raw_content}")
      @lines = @raw_content.lines.reject do |line|
        line.nil? || line.match(/^#(?!include)|^\s*$/) || @ignored_directives.any? do |directive|
          line.include?(directive)
        end
      end.map(&:strip)
      Inspec::Log.debug("lines: #{@lines}")
    end

    def parse_content
      aliases = %w[Defaults Cmnd_Alias User_Alias Host_Alias Runas_Alias]
      settings_lines = @lines.select { |line| line.match(/^(#{aliases.join("|")})/) }
      userspec_lines = @lines.reject { |line| line.match(/^(#{aliases.join("|")})/) }
      Inspec::Log.debug("settings_lines: #{settings_lines}")
      Inspec::Log.debug("userspec_lines: #{userspec_lines}")
      parsed_settings = settings_hash(settings_lines)
      Inspec::Log.debug("parsed_settings: #{parsed_settings}")
      @settings = parsed_settings
      @settings_filter = SudoersSettingsFilter.new(parsed_settings)
      @table = SudoersUserSpecTable.new(userspec_lines)
      Inspec::Log.debug("@table: #{@table.table}")
    end

    def settings_hash(settings_lines)
      sudo_config_hash = {}
      sudo_config_hash['Defaults'] = {
        'user_bindings' => {},
        'command_bindings' => {},
        'host_bindings' => {},
        'negated_command_bindings' => {}
      }

      settings_lines.each do |line|
        if line.start_with?('Defaults')
          parse_defaults_line(line, sudo_config_hash)
        else
          # Handle non-Defaults entries (aliases, etc.)
          category, spec = line.split(/\s+/, 2)
          sudo_config_hash[category] ||= {}

          if spec.include?('=')
            key, value = spec.split('=', 2).map(&:strip)
            sudo_config_hash[category][key] = value.split(/,\s*/)
          end
        end
      end

      sudo_config_hash
    end

    def parse_commands(command_string)
      return [] if command_string.nil?

      # Handle complex command strings with tags
      commands = command_string.split(/,\s*/)
      commands.map do |cmd|
        # Strip any tags from the command
        cmd.sub(/^(LOG_INPUT:|LOG_OUTPUT:|NOPASSWD:|NOEXEC:)+\s*/, '').strip
      end
    end

    def parse_defaults_line(line, hash)
      if line =~ /^Defaults([>@:!])(.*?)\s+(.*)$/
        binding_type = Regexp.last_match(1)
        target = Regexp.last_match(2).strip
        rest = Regexp.last_match(3).strip

        # Determine which binding hash to use
        binding_hash = case binding_type
                       when ':' then hash['Defaults']['user_bindings']
                       when '>' then hash['Defaults']['command_bindings']
                       when '@' then hash['Defaults']['host_bindings']
                       when '!' then hash['Defaults']['negated_command_bindings']
                       end

        binding_hash[target] ||= {}

        if rest.include?('=')
          key, value = rest.split('=', 2).map(&:strip)
          binding_hash[target][key] = [value]
        else
          binding_hash[target][rest] = []
        end
      else
        # Handle global defaults
        _, setting = line.split(/\s+/, 2)
        if setting.include?('=')
          key, value = setting.split('=', 2).map(&:strip)
          hash['Defaults'][key] = [value]
        else
          hash['Defaults'][setting.strip] = []
        end
      end
    end
  end
end

# This class is responsible for parsing and filtering user specifications in the sudoers file.
class SudoersUserSpecTable
  filter = FilterTable.create
  filter.register_column(:users, field: :users)
  filter.register_column(:hosts, field: :hosts)
  filter.register_column(:run_as, field: :run_as)
  filter.register_column(:tags, field: :tags)
  filter.register_column(:commands, field: :commands)
  filter.register_custom_matcher(:exists?) { |x| !x.entries.empty? }
  filter.register_custom_matcher(:empty?) { |x| x.entries.empty? }
  filter.install_filter_methods_on_resource(self, :table)

  attr_reader :table

  def initialize(userspec_lines)
    Inspec::Log.debug("Initializing SudoersUserSpecTable with userspec_lines: #{userspec_lines}")
    tags = %w[NOPASSWD PASSWD NOEXEC EXEC SETENV NOSETENV LOG_INPUT NOLOG_INPUT LOG_OUTPUT NOLOG_OUTPUT]
    @table = userspec_lines.map.with_index do |line, index|
      line_hash = {}
      parsed_line = line.match(/^(?<users>\S+)\s+(?<hosts>[^\s=]+)\s*=\s*(\((?<run_as>[^)]+)\))?\s*(?<tags>(#{tags.join(":|")}:)+)?\s*(?<commands>.*)$/)
      Inspec::Log.debug("Line #{index + 1}: #{line}")
      if parsed_line.nil?
        Inspec::Log.warn("Unable to parse line #{index + 1}: #{line}")
      else
        Inspec::Log.debug("parsed_line: #{parsed_line}")
        line_hash[:users] = parsed_line['users']
        line_hash[:hosts] = parsed_line['hosts']
        line_hash[:run_as] = parsed_line['run_as'] unless parsed_line['run_as'].nil?
        line_hash[:tags] = parsed_line['tags'] unless parsed_line['tags'].nil?
        line_hash[:commands] = parsed_line['commands'].split(/,\s*/).map(&:strip)
      end
      line_hash unless line_hash.empty?
    end.compact
    Inspec::Log.debug("@table: #{@table}")
  end

  def to_s
    'Sudoers User Permissions Table'
  end
end
